package wire

import (
	"encoding/hex"
	"encoding/json"
	"math"
	"os"
	"path/filepath"
	"testing"
)

// fixtureMetadata represents the JSON metadata generated by Node.js
type fixtureMetadata struct {
	Description string          `json:"description"`
	NodeVersion string          `json:"nodeVersion"`
	V8Version   string          `json:"v8Version"`
	ByteLength  int             `json:"byteLength"`
	HexDump     string          `json:"hexDump"`
	Value       json.RawMessage `json:"value"`
}

func loadFixture(t *testing.T, name string) ([]byte, *fixtureMetadata) {
	t.Helper()
	fixturesDir := filepath.Join("..", "..", "testdata", "fixtures")

	binPath := filepath.Join(fixturesDir, name+".bin")
	jsonPath := filepath.Join(fixturesDir, name+".json")

	binData, err := os.ReadFile(binPath)
	if err != nil {
		t.Fatalf("failed to read %s: %v", binPath, err)
	}

	jsonData, err := os.ReadFile(jsonPath)
	if err != nil {
		t.Fatalf("failed to read %s: %v", jsonPath, err)
	}

	var meta fixtureMetadata
	if err := json.Unmarshal(jsonData, &meta); err != nil {
		t.Fatalf("failed to parse %s: %v", jsonPath, err)
	}

	return binData, &meta
}

func TestReadByte(t *testing.T) {
	r := NewReader([]byte{0x01, 0x02, 0x03})

	b, err := r.ReadByte()
	if err != nil {
		t.Fatalf("ReadByte failed: %v", err)
	}
	if b != 0x01 {
		t.Errorf("expected 0x01, got 0x%02x", b)
	}

	if r.Pos() != 1 {
		t.Errorf("expected pos 1, got %d", r.Pos())
	}

	// Read remaining
	r.ReadByte()
	r.ReadByte()

	// Should get EOF
	_, err = r.ReadByte()
	if err != ErrUnexpectedEOF {
		t.Errorf("expected ErrUnexpectedEOF, got %v", err)
	}
}

func TestReadVarint(t *testing.T) {
	tests := []struct {
		name     string
		input    []byte
		expected uint64
		wantErr  bool
	}{
		{"zero", []byte{0x00}, 0, false},
		{"one", []byte{0x01}, 1, false},
		{"127", []byte{0x7f}, 127, false},
		{"128", []byte{0x80, 0x01}, 128, false},
		{"255", []byte{0xff, 0x01}, 255, false},
		{"300", []byte{0xac, 0x02}, 300, false},
		{"16384", []byte{0x80, 0x80, 0x01}, 16384, false},
		// V8 version 15 encoded as varint 0x0f
		{"v8_version_15", []byte{0x0f}, 15, false},
		// Multi-byte varint for larger numbers
		{"large", []byte{0xff, 0xff, 0xff, 0xff, 0x0f}, 0xffffffff, false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			r := NewReader(tt.input)
			got, err := r.ReadVarint()
			if (err != nil) != tt.wantErr {
				t.Errorf("ReadVarint() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if got != tt.expected {
				t.Errorf("ReadVarint() = %d, expected %d", got, tt.expected)
			}
		})
	}
}

func TestReadVarintFromFixtures(t *testing.T) {
	// Test reading version header from a fixture
	// All V8 fixtures start with: 0xFF (version tag), then version as varint
	binData, meta := loadFixture(t, "null")

	r := NewReader(binData)

	// First byte should be 0xFF (version tag)
	versionTag, err := r.ReadByte()
	if err != nil {
		t.Fatalf("failed to read version tag: %v", err)
	}
	if versionTag != 0xFF {
		t.Errorf("expected version tag 0xFF, got 0x%02x", versionTag)
	}

	// Next is version number as varint
	version, err := r.ReadVarint()
	if err != nil {
		t.Fatalf("failed to read version: %v", err)
	}
	// Node.js 22 uses V8 format version 15
	if version < 13 || version > 16 {
		t.Errorf("unexpected version %d, expected 13-16 (got from %s)", version, meta.NodeVersion)
	}
	t.Logf("V8 serialization version: %d (Node %s)", version, meta.NodeVersion)
}

func TestZigZagDecode(t *testing.T) {
	tests := []struct {
		encoded  uint64
		expected int64
	}{
		{0, 0},
		{1, -1},
		{2, 1},
		{3, -2},
		{4, 2},
		{83, -42},                 // -42 encoded
		{84, 42},                  // 42 encoded
		{0xfffffffe, 0x7fffffff},  // int32 max
		{0xffffffff, -0x80000000}, // int32 min
	}

	for _, tt := range tests {
		got := ZigZagDecode(tt.encoded)
		if got != tt.expected {
			t.Errorf("ZigZagDecode(%d) = %d, expected %d", tt.encoded, got, tt.expected)
		}
	}
}

func TestReadInt32FromFixtures(t *testing.T) {
	tests := []struct {
		fixture  string
		expected int32
	}{
		{"int32-zero", 0},
		{"int32-positive", 42},
		{"int32-negative", -42},
		{"int32-max", 2147483647},
		{"int32-min", -2147483648},
	}

	for _, tt := range tests {
		t.Run(tt.fixture, func(t *testing.T) {
			binData, meta := loadFixture(t, tt.fixture)
			t.Logf("Hex: %s", meta.HexDump)

			r := NewReader(binData)

			// Skip version header (0xFF + varint)
			vTag, _ := r.ReadByte()
			if vTag != 0xFF {
				t.Fatalf("expected version tag 0xFF, got 0x%02x", vTag)
			}
			_, _ = r.ReadVarint() // version number

			// Read type tag
			tag, err := r.ReadByte()
			if err != nil {
				t.Fatalf("failed to read tag: %v", err)
			}
			if tag != 'I' { // 0x49 = 'I' = Int32 tag
				t.Fatalf("expected Int32 tag 'I' (0x49), got 0x%02x", tag)
			}

			// Read ZigZag-encoded value
			got, err := r.ReadZigZag32()
			if err != nil {
				t.Fatalf("failed to read int32: %v", err)
			}

			if got != tt.expected {
				t.Errorf("got %d, expected %d", got, tt.expected)
			}
		})
	}
}

func TestReadDoubleFromFixtures(t *testing.T) {
	tests := []struct {
		fixture  string
		expected float64
		isNaN    bool
	}{
		{"double-pi", 3.14159265358979, false},
		{"double-negative-zero", math.Copysign(0, -1), false},
		{"double-infinity", math.Inf(1), false},
		{"double-neg-infinity", math.Inf(-1), false},
		{"double-nan", 0, true},
		{"double-large", 8589934592, false}, // 2^33
		{"double-max", math.MaxFloat64, false},
		{"double-min-positive", math.SmallestNonzeroFloat64, false},
	}

	for _, tt := range tests {
		t.Run(tt.fixture, func(t *testing.T) {
			binData, meta := loadFixture(t, tt.fixture)
			t.Logf("Hex: %s", meta.HexDump)

			r := NewReader(binData)

			// Skip version header
			r.ReadByte()   // 0xFF
			r.ReadVarint() // version

			// Read type tag
			tag, err := r.ReadByte()
			if err != nil {
				t.Fatalf("failed to read tag: %v", err)
			}
			if tag != 'N' { // 0x4e = 'N' = Double tag
				t.Fatalf("expected Double tag 'N' (0x4e), got 0x%02x ('%c')", tag, tag)
			}

			// Read double value
			got, err := r.ReadDouble()
			if err != nil {
				t.Fatalf("failed to read double: %v", err)
			}

			if tt.isNaN {
				if !math.IsNaN(got) {
					t.Errorf("expected NaN, got %v", got)
				}
			} else if math.IsNaN(tt.expected) {
				if !math.IsNaN(got) {
					t.Errorf("expected NaN, got %v", got)
				}
			} else if tt.expected == 0 && math.Signbit(tt.expected) {
				// Negative zero
				if got != 0 || !math.Signbit(got) {
					t.Errorf("expected -0, got %v (signbit=%v)", got, math.Signbit(got))
				}
			} else if math.IsInf(tt.expected, 0) {
				if got != tt.expected {
					t.Errorf("expected %v, got %v", tt.expected, got)
				}
			} else {
				if got != tt.expected {
					t.Errorf("got %v, expected %v", got, tt.expected)
				}
			}
		})
	}
}

func TestReadOneByteStringFromFixtures(t *testing.T) {
	tests := []struct {
		fixture  string
		expected string
	}{
		{"string-empty", ""},
		{"string-onebyte", "hello"},
		{"string-hello-world", "Hello, World!"},
		{"string-latin1", "caf√©"},
	}

	for _, tt := range tests {
		t.Run(tt.fixture, func(t *testing.T) {
			binData, meta := loadFixture(t, tt.fixture)
			t.Logf("Hex: %s", meta.HexDump)

			r := NewReader(binData)

			// Skip version header
			r.ReadByte()   // 0xFF
			r.ReadVarint() // version

			// Read type tag
			tag, err := r.ReadByte()
			if err != nil {
				t.Fatalf("failed to read tag: %v", err)
			}
			if tag != '"' { // 0x22 = '"' = OneByteString tag
				t.Fatalf("expected OneByteString tag '\"' (0x22), got 0x%02x ('%c')", tag, tag)
			}

			// Read string length (varint)
			length, err := r.ReadVarint32()
			if err != nil {
				t.Fatalf("failed to read string length: %v", err)
			}

			// Read string data
			got, err := r.ReadOneByteString(int(length))
			if err != nil {
				t.Fatalf("failed to read string: %v", err)
			}

			if got != tt.expected {
				t.Errorf("got %q, expected %q", got, tt.expected)
			}
		})
	}
}

func TestReadTwoByteStringFromFixtures(t *testing.T) {
	tests := []struct {
		fixture  string
		expected string
	}{
		{"string-twobyte-chinese", "‰Ω†Â•Ω‰∏ñÁïå"},
		{"string-twobyte-emoji", "‰Ω†Â•Ωüåç"},
		{"string-emoji-only", "üòÄüòÅüòÇ"},
	}

	for _, tt := range tests {
		t.Run(tt.fixture, func(t *testing.T) {
			binData, meta := loadFixture(t, tt.fixture)
			t.Logf("Hex: %s", meta.HexDump)

			r := NewReader(binData)

			// Skip version header
			r.ReadByte()   // 0xFF
			r.ReadVarint() // version

			// Read type tag
			tag, err := r.ReadByte()
			if err != nil {
				t.Fatalf("failed to read tag: %v", err)
			}
			if tag != 'c' { // 0x63 = 'c' = TwoByteString tag
				t.Fatalf("expected TwoByteString tag 'c' (0x63), got 0x%02x ('%c')", tag, tag)
			}

			// Read string length in BYTES (not UTF-16 code units!)
			// V8 stores byte length for two-byte strings
			byteLength, err := r.ReadVarint32()
			if err != nil {
				t.Fatalf("failed to read string length: %v", err)
			}

			// Convert byte length to UTF-16 code unit count
			utf16Length := int(byteLength) / 2

			// Read string data
			got, err := r.ReadTwoByteString(utf16Length)
			if err != nil {
				t.Fatalf("failed to read string: %v", err)
			}

			if got != tt.expected {
				t.Errorf("got %q, expected %q", got, tt.expected)
			}
		})
	}
}

func TestReadLongStringFromFixtures(t *testing.T) {
	// Test the 256-character two-byte string which needs alignment
	binData, meta := loadFixture(t, "string-256-twobyte")
	t.Logf("Hex (first 100 chars): %s...", meta.HexDump[:100])

	r := NewReader(binData)

	// Skip version header
	r.ReadByte()   // 0xFF
	r.ReadVarint() // version

	// V8 may include a padding byte (0x00) before the tag for alignment purposes
	// Check the hex dump: ff0f00 - the 00 is padding before the 'c' tag
	tag, err := r.ReadByte()
	if err != nil {
		t.Fatalf("failed to read first byte: %v", err)
	}

	// If it's 0x00, it's a padding byte; read the actual tag
	if tag == 0x00 {
		tag, err = r.ReadByte()
		if err != nil {
			t.Fatalf("failed to read tag after padding: %v", err)
		}
	}

	if tag != 'c' {
		t.Fatalf("expected TwoByteString tag 'c' (0x63), got 0x%02x ('%c')", tag, tag)
	}

	// Length is encoded as varint in BYTES (not code units)
	byteLength, err := r.ReadVarint32()
	if err != nil {
		t.Fatalf("failed to read length: %v", err)
	}
	t.Logf("String byte length: %d (= %d UTF-16 code units)", byteLength, byteLength/2)

	// Convert to UTF-16 code unit count
	utf16Length := int(byteLength) / 2

	// Read string
	got, err := r.ReadTwoByteString(utf16Length)
	if err != nil {
		t.Fatalf("failed to read string: %v", err)
	}

	// Should be 256 repetitions of ‰∏≠ (U+4E2D)
	expected := ""
	for i := 0; i < 256; i++ {
		expected += "‰∏≠"
	}
	if got != expected {
		t.Errorf("got string of length %d runes, expected length %d runes", len([]rune(got)), len([]rune(expected)))
		if len(got) > 30 {
			t.Errorf("got prefix: %q...", got[:30])
		}
	}
}

func TestAlignment(t *testing.T) {
	// Create a reader with position at odd offset
	data := []byte{0x00, 0x01, 0x02, 0x03, 0x04, 0x05}
	r := NewReader(data)

	// Read one byte to get to position 1
	r.ReadByte()
	if r.Pos() != 1 {
		t.Fatalf("expected pos 1, got %d", r.Pos())
	}

	// Align to 2-byte boundary
	r.AlignTo(2)
	if r.Pos() != 2 {
		t.Errorf("after AlignTo(2), expected pos 2, got %d", r.Pos())
	}

	// Already aligned, should stay at 2
	r.AlignTo(2)
	if r.Pos() != 2 {
		t.Errorf("already aligned, expected pos 2, got %d", r.Pos())
	}

	// Align to 4
	r.AlignTo(4)
	if r.Pos() != 4 {
		t.Errorf("after AlignTo(4), expected pos 4, got %d", r.Pos())
	}
}

func TestExplainInt32ByteLayout(t *testing.T) {
	// Explain the byte layout of int32 42
	binData, _ := loadFixture(t, "int32-positive")
	hexStr := hex.EncodeToString(binData)

	t.Logf("V8 serialized int32(42) = %s", hexStr)
	t.Logf("")
	t.Logf("Byte breakdown:")
	t.Logf("  ff     = Version tag (0xFF indicates versioned format)")
	t.Logf("  0f     = Version number as varint (15 = 0x0F)")
	t.Logf("  49     = Type tag 'I' (0x49 = Int32)")
	t.Logf("  54     = ZigZag-encoded value as varint")
	t.Logf("")
	t.Logf("ZigZag encoding: 42 ‚Üí 84 (positive numbers: n*2)")
	t.Logf("Varint encoding: 84 = 0x54 (fits in one byte, high bit clear)")

	// Verify the explanation
	if hexStr != "ff0f4954" {
		t.Errorf("expected ff0f4954, got %s", hexStr)
	}

	// Show negative example
	binDataNeg, _ := loadFixture(t, "int32-negative")
	hexStrNeg := hex.EncodeToString(binDataNeg)

	t.Logf("")
	t.Logf("V8 serialized int32(-42) = %s", hexStrNeg)
	t.Logf("")
	t.Logf("Byte breakdown:")
	t.Logf("  ff     = Version tag")
	t.Logf("  0f     = Version 15")
	t.Logf("  49     = Type tag 'I' (Int32)")
	t.Logf("  53     = ZigZag-encoded value as varint")
	t.Logf("")
	t.Logf("ZigZag encoding: -42 ‚Üí 83 (negative numbers: |n|*2 - 1)")
	t.Logf("Varint encoding: 83 = 0x53 (fits in one byte)")

	if hexStrNeg != "ff0f4953" {
		t.Errorf("expected ff0f4953, got %s", hexStrNeg)
	}
}

func TestReadDateFromFixtures(t *testing.T) {
	// Known dates with exact millisecond values
	tests := []struct {
		fixture    string
		expectedMs float64
	}{
		{"date-epoch", 0},
		{"date-before-epoch", -86400000},
		{"date-max", 8640000000000000},
		{"date-min", -8640000000000000},
	}

	for _, tt := range tests {
		t.Run(tt.fixture, func(t *testing.T) {
			binData, meta := loadFixture(t, tt.fixture)
			t.Logf("Hex: %s", meta.HexDump)

			r := NewReader(binData)

			// Skip version header
			r.ReadByte()   // 0xFF
			r.ReadVarint() // version

			// Read type tag
			tag, err := r.ReadByte()
			if err != nil {
				t.Fatalf("failed to read tag: %v", err)
			}
			if tag != 'D' { // 0x44 = 'D' = Date tag
				t.Fatalf("expected Date tag 'D' (0x44), got 0x%02x ('%c')", tag, tag)
			}

			// Date is stored as double (ms since epoch)
			got, err := r.ReadDouble()
			if err != nil {
				t.Fatalf("failed to read date: %v", err)
			}

			if got != tt.expectedMs {
				t.Errorf("got %v ms, expected %v ms", got, tt.expectedMs)
			}
		})
	}

	// For date-recent, just verify we can read it and it's a reasonable value
	t.Run("date-recent", func(t *testing.T) {
		binData, meta := loadFixture(t, "date-recent")
		t.Logf("Hex: %s", meta.HexDump)

		r := NewReader(binData)
		r.ReadByte()   // 0xFF
		r.ReadVarint() // version

		tag, _ := r.ReadByte()
		if tag != 'D' {
			t.Fatalf("expected Date tag 'D', got 0x%02x", tag)
		}

		ms, err := r.ReadDouble()
		if err != nil {
			t.Fatalf("failed to read date: %v", err)
		}

		// 2024-01-15T12:30:45.123Z should be around 1.705e12 ms
		if ms < 1.7e12 || ms > 1.8e12 {
			t.Errorf("date-recent ms=%v seems out of expected range", ms)
		}
		t.Logf("date-recent: %.0f ms", ms)
	})
}

func TestPrimitiveTagsFromFixtures(t *testing.T) {
	tests := []struct {
		fixture     string
		expectedTag byte
	}{
		{"null", '0'},      // 0x30
		{"undefined", '_'}, // 0x5f
		{"true", 'T'},      // 0x54
		{"false", 'F'},     // 0x46
	}

	for _, tt := range tests {
		t.Run(tt.fixture, func(t *testing.T) {
			binData, meta := loadFixture(t, tt.fixture)
			t.Logf("Hex: %s", meta.HexDump)

			r := NewReader(binData)

			// Skip version header
			r.ReadByte()   // 0xFF
			r.ReadVarint() // version

			// Read type tag
			tag, err := r.ReadByte()
			if err != nil {
				t.Fatalf("failed to read tag: %v", err)
			}

			if tag != tt.expectedTag {
				t.Errorf("expected tag '%c' (0x%02x), got '%c' (0x%02x)",
					tt.expectedTag, tt.expectedTag, tag, tag)
			}

			// These are single-byte types - no additional data
			if !r.EOF() {
				t.Errorf("expected EOF after primitive tag, but %d bytes remain", r.Remaining())
			}
		})
	}
}
