package v8serialize

import (
	"encoding/json"
	"fmt"
	"math"
	"math/big"
	"os"
	"path/filepath"
	"strings"
	"testing"
	"time"
)

// fixtureMetadata represents the JSON metadata generated by Node.js
type fixtureMetadata struct {
	Description string          `json:"description"`
	NodeVersion string          `json:"nodeVersion"`
	V8Version   string          `json:"v8Version"`
	ByteLength  int             `json:"byteLength"`
	HexDump     string          `json:"hexDump"`
	Value       json.RawMessage `json:"value"`
}

func loadFixture(t *testing.T, name string) ([]byte, *fixtureMetadata) {
	t.Helper()
	fixturesDir := filepath.Join("..", "..", "testdata", "fixtures")

	binPath := filepath.Join(fixturesDir, name+".bin")
	jsonPath := filepath.Join(fixturesDir, name+".json")

	binData, err := os.ReadFile(binPath)
	if err != nil {
		t.Fatalf("failed to read %s: %v", binPath, err)
	}

	jsonData, err := os.ReadFile(jsonPath)
	if err != nil {
		t.Fatalf("failed to read %s: %v", jsonPath, err)
	}

	var meta fixtureMetadata
	if err := json.Unmarshal(jsonData, &meta); err != nil {
		t.Fatalf("failed to parse %s: %v", jsonPath, err)
	}

	return binData, &meta
}

func TestDeserializePrimitives(t *testing.T) {
	tests := []struct {
		fixture string
		check   func(t *testing.T, v Value)
	}{
		{"null", func(t *testing.T, v Value) {
			if !v.IsNull() {
				t.Errorf("expected null, got %s", v.Type())
			}
		}},
		{"undefined", func(t *testing.T, v Value) {
			if !v.IsUndefined() {
				t.Errorf("expected undefined, got %s", v.Type())
			}
		}},
		{"true", func(t *testing.T, v Value) {
			if !v.IsBool() || !v.AsBool() {
				t.Errorf("expected true, got %#v", v)
			}
		}},
		{"false", func(t *testing.T, v Value) {
			if !v.IsBool() || v.AsBool() {
				t.Errorf("expected false, got %#v", v)
			}
		}},
	}

	for _, tt := range tests {
		t.Run(tt.fixture, func(t *testing.T) {
			binData, _ := loadFixture(t, tt.fixture)
			v, err := Deserialize(binData)
			if err != nil {
				t.Fatalf("Deserialize failed: %v", err)
			}
			tt.check(t, v)
		})
	}
}

func TestDeserializeInt32(t *testing.T) {
	tests := []struct {
		fixture  string
		expected int32
	}{
		{"int32-zero", 0},
		{"int32-positive", 42},
		{"int32-negative", -42},
		{"int32-max", 2147483647},
		{"int32-min", -2147483648},
	}

	for _, tt := range tests {
		t.Run(tt.fixture, func(t *testing.T) {
			binData, _ := loadFixture(t, tt.fixture)
			v, err := Deserialize(binData)
			if err != nil {
				t.Fatalf("Deserialize failed: %v", err)
			}
			if v.Type() != TypeInt32 {
				t.Fatalf("expected TypeInt32, got %s", v.Type())
			}
			if got := v.AsInt32(); got != tt.expected {
				t.Errorf("got %d, expected %d", got, tt.expected)
			}
		})
	}
}

func TestDeserializeDouble(t *testing.T) {
	tests := []struct {
		fixture string
		check   func(t *testing.T, f float64)
	}{
		{"double-pi", func(t *testing.T, f float64) {
			if math.Abs(f-3.14159265358979) > 1e-14 {
				t.Errorf("expected pi, got %v", f)
			}
		}},
		{"double-negative-zero", func(t *testing.T, f float64) {
			if f != 0 || !math.Signbit(f) {
				t.Errorf("expected -0, got %v (signbit=%v)", f, math.Signbit(f))
			}
		}},
		{"double-infinity", func(t *testing.T, f float64) {
			if !math.IsInf(f, 1) {
				t.Errorf("expected +Inf, got %v", f)
			}
		}},
		{"double-neg-infinity", func(t *testing.T, f float64) {
			if !math.IsInf(f, -1) {
				t.Errorf("expected -Inf, got %v", f)
			}
		}},
		{"double-nan", func(t *testing.T, f float64) {
			if !math.IsNaN(f) {
				t.Errorf("expected NaN, got %v", f)
			}
		}},
		{"double-large", func(t *testing.T, f float64) {
			if f != 8589934592 {
				t.Errorf("expected 2^33, got %v", f)
			}
		}},
		{"double-max", func(t *testing.T, f float64) {
			if f != math.MaxFloat64 {
				t.Errorf("expected MaxFloat64, got %v", f)
			}
		}},
		{"double-min-positive", func(t *testing.T, f float64) {
			if f != math.SmallestNonzeroFloat64 {
				t.Errorf("expected SmallestNonzeroFloat64, got %v", f)
			}
		}},
	}

	for _, tt := range tests {
		t.Run(tt.fixture, func(t *testing.T) {
			binData, _ := loadFixture(t, tt.fixture)
			v, err := Deserialize(binData)
			if err != nil {
				t.Fatalf("Deserialize failed: %v", err)
			}
			if v.Type() != TypeDouble {
				t.Fatalf("expected TypeDouble, got %s", v.Type())
			}
			tt.check(t, v.AsDouble())
		})
	}
}

func TestDeserializeBigInt(t *testing.T) {
	tests := []struct {
		fixture  string
		expected string
	}{
		{"bigint-zero", "0"},
		{"bigint-positive", "42"},
		{"bigint-negative", "-42"},
		{"bigint-beyond-safe", "9007199254740993"},
		{"bigint-huge", "123456789012345678901234567890"},
		{"bigint-huge-negative", "-123456789012345678901234567890"},
	}

	for _, tt := range tests {
		t.Run(tt.fixture, func(t *testing.T) {
			binData, _ := loadFixture(t, tt.fixture)
			v, err := Deserialize(binData)
			if err != nil {
				t.Fatalf("Deserialize failed: %v", err)
			}
			if v.Type() != TypeBigInt {
				t.Fatalf("expected TypeBigInt, got %s", v.Type())
			}
			expected, _ := new(big.Int).SetString(tt.expected, 10)
			if got := v.AsBigInt(); got.Cmp(expected) != 0 {
				t.Errorf("got %s, expected %s", got.String(), tt.expected)
			}
		})
	}
}

func TestDeserializeStrings(t *testing.T) {
	tests := []struct {
		fixture  string
		expected string
	}{
		{"string-empty", ""},
		{"string-onebyte", "hello"},
		{"string-hello-world", "Hello, World!"},
		{"string-latin1", "caf√©"},
		{"string-twobyte-chinese", "‰Ω†Â•Ω‰∏ñÁïå"},
		{"string-twobyte-emoji", "‰Ω†Â•Ωüåç"},
		{"string-emoji-only", "üòÄüòÅüòÇ"},
	}

	for _, tt := range tests {
		t.Run(tt.fixture, func(t *testing.T) {
			binData, _ := loadFixture(t, tt.fixture)
			v, err := Deserialize(binData)
			if err != nil {
				t.Fatalf("Deserialize failed: %v", err)
			}
			if v.Type() != TypeString {
				t.Fatalf("expected TypeString, got %s", v.Type())
			}
			if got := v.AsString(); got != tt.expected {
				t.Errorf("got %q, expected %q", got, tt.expected)
			}
		})
	}
}

func TestDeserializeLongStrings(t *testing.T) {
	t.Run("string-256", func(t *testing.T) {
		binData, _ := loadFixture(t, "string-256")
		v, err := Deserialize(binData)
		if err != nil {
			t.Fatalf("Deserialize failed: %v", err)
		}
		if v.Type() != TypeString {
			t.Fatalf("expected TypeString, got %s", v.Type())
		}
		expected := strings.Repeat("a", 256)
		if got := v.AsString(); got != expected {
			t.Errorf("got string of length %d, expected %d", len(got), len(expected))
		}
	})

	t.Run("string-256-twobyte", func(t *testing.T) {
		binData, _ := loadFixture(t, "string-256-twobyte")
		v, err := Deserialize(binData)
		if err != nil {
			t.Fatalf("Deserialize failed: %v", err)
		}
		if v.Type() != TypeString {
			t.Fatalf("expected TypeString, got %s", v.Type())
		}
		expected := strings.Repeat("‰∏≠", 256)
		if got := v.AsString(); got != expected {
			t.Errorf("got string of length %d runes, expected %d", len([]rune(got)), len([]rune(expected)))
		}
	})
}

func TestDeserializeDates(t *testing.T) {
	tests := []struct {
		fixture    string
		expectedMs int64
	}{
		{"date-epoch", 0},
		{"date-before-epoch", -86400000},
		{"date-max", 8640000000000000},
		{"date-min", -8640000000000000},
	}

	for _, tt := range tests {
		t.Run(tt.fixture, func(t *testing.T) {
			binData, _ := loadFixture(t, tt.fixture)
			v, err := Deserialize(binData)
			if err != nil {
				t.Fatalf("Deserialize failed: %v", err)
			}
			if v.Type() != TypeDate {
				t.Fatalf("expected TypeDate, got %s", v.Type())
			}
			got := v.AsDate().UnixMilli()
			if got != tt.expectedMs {
				t.Errorf("got %d ms, expected %d ms", got, tt.expectedMs)
			}
		})
	}

	t.Run("date-recent", func(t *testing.T) {
		binData, _ := loadFixture(t, "date-recent")
		v, err := Deserialize(binData)
		if err != nil {
			t.Fatalf("Deserialize failed: %v", err)
		}
		got := v.AsDate()
		// Should be around 2024-01-15
		if got.Year() != 2024 || got.Month() != time.January || got.Day() != 15 {
			t.Errorf("expected 2024-01-15, got %s", got.Format(time.RFC3339))
		}
	})
}

func TestDeserializeVersion(t *testing.T) {
	binData, meta := loadFixture(t, "null")
	d := NewDeserializer(binData)
	_, err := d.Deserialize()
	if err != nil {
		t.Fatalf("Deserialize failed: %v", err)
	}

	version := d.Version()
	t.Logf("V8 format version: %d (from Node %s)", version, meta.NodeVersion)

	if version < 13 || version > 15 {
		t.Errorf("unexpected version %d", version)
	}
}

func TestDeserializeInvalidData(t *testing.T) {
	tests := []struct {
		name    string
		data    []byte
		wantErr string
	}{
		{"empty", []byte{}, "invalid header"},
		{"no version", []byte{0x30}, "invalid header"},
		{"wrong version tag", []byte{0xFE, 0x0F, 0x30}, "invalid header"},
		{"version too old", []byte{0xFF, 0x0C, 0x30}, "unsupported version"},
		{"truncated int32", []byte{0xFF, 0x0F, 'I'}, "unexpected end"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			_, err := Deserialize(tt.data)
			if err == nil {
				t.Fatalf("expected error, got nil")
			}
			if !strings.Contains(err.Error(), tt.wantErr) {
				t.Errorf("error %q doesn't contain %q", err.Error(), tt.wantErr)
			}
		})
	}
}

func TestValueAccessors(t *testing.T) {
	// Test that accessors panic on wrong type
	t.Run("AsBool panics on int", func(t *testing.T) {
		defer func() {
			if r := recover(); r == nil {
				t.Errorf("expected panic")
			}
		}()
		v := Int32(42)
		v.AsBool()
	})

	t.Run("AsInt32 panics on string", func(t *testing.T) {
		defer func() {
			if r := recover(); r == nil {
				t.Errorf("expected panic")
			}
		}()
		v := String("hello")
		v.AsInt32()
	})

	// Test AsNumber works on all numeric types
	t.Run("AsNumber on int32", func(t *testing.T) {
		v := Int32(42)
		if got := v.AsNumber(); got != 42 {
			t.Errorf("expected 42, got %v", got)
		}
	})

	t.Run("AsNumber on uint32", func(t *testing.T) {
		v := Uint32(3000000000)
		if got := v.AsNumber(); got != 3000000000 {
			t.Errorf("expected 3000000000, got %v", got)
		}
	})

	t.Run("AsNumber on double", func(t *testing.T) {
		v := Double(3.14)
		if got := v.AsNumber(); got != 3.14 {
			t.Errorf("expected 3.14, got %v", got)
		}
	})
}

func TestGoStringer(t *testing.T) {
	tests := []struct {
		value    Value
		expected string
	}{
		{Undefined(), "undefined"},
		{Null(), "null"},
		{Bool(true), "true"},
		{Bool(false), "false"},
		{Int32(42), "42"},
		{Double(3.14), "3.14"},
		{String("hello"), `"hello"`},
		{Hole(), "<hole>"},
	}

	for _, tt := range tests {
		got := tt.value.GoString()
		if got != tt.expected {
			t.Errorf("GoString() = %q, expected %q", got, tt.expected)
		}
	}
}

func TestDeserializeObjects(t *testing.T) {
	t.Run("object-empty", func(t *testing.T) {
		binData, _ := loadFixture(t, "object-empty")
		v, err := Deserialize(binData)
		if err != nil {
			t.Fatalf("Deserialize failed: %v", err)
		}
		if v.Type() != TypeObject {
			t.Fatalf("expected TypeObject, got %s", v.Type())
		}
		obj := v.AsObject()
		if len(obj) != 0 {
			t.Errorf("expected empty object, got %d properties", len(obj))
		}
	})

	t.Run("object-simple", func(t *testing.T) {
		binData, _ := loadFixture(t, "object-simple")
		v, err := Deserialize(binData)
		if err != nil {
			t.Fatalf("Deserialize failed: %v", err)
		}
		obj := v.AsObject()
		if obj["a"].AsInt32() != 1 {
			t.Errorf("a: expected 1, got %v", obj["a"])
		}
		if obj["b"].AsInt32() != 2 {
			t.Errorf("b: expected 2, got %v", obj["b"])
		}
	})

	t.Run("object-nested", func(t *testing.T) {
		binData, _ := loadFixture(t, "object-nested")
		v, err := Deserialize(binData)
		if err != nil {
			t.Fatalf("Deserialize failed: %v", err)
		}
		obj := v.AsObject()
		nested := obj["nested"].AsObject()
		if nested["inner"].AsString() != "value" {
			t.Errorf("nested.inner: expected 'value', got %v", nested["inner"])
		}
	})

	t.Run("object-types", func(t *testing.T) {
		binData, _ := loadFixture(t, "object-types")
		v, err := Deserialize(binData)
		if err != nil {
			t.Fatalf("Deserialize failed: %v", err)
		}
		obj := v.AsObject()
		if obj["num"].AsInt32() != 42 {
			t.Errorf("num: expected 42, got %v", obj["num"])
		}
		if obj["str"].AsString() != "hello" {
			t.Errorf("str: expected 'hello', got %v", obj["str"])
		}
		if !obj["bool"].AsBool() {
			t.Errorf("bool: expected true")
		}
		if !obj["nil"].IsNull() {
			t.Errorf("nil: expected null, got %v", obj["nil"])
		}
	})
}

func TestDeserializeArrays(t *testing.T) {
	t.Run("array-empty", func(t *testing.T) {
		binData, _ := loadFixture(t, "array-empty")
		v, err := Deserialize(binData)
		if err != nil {
			t.Fatalf("Deserialize failed: %v", err)
		}
		if v.Type() != TypeArray {
			t.Fatalf("expected TypeArray, got %s", v.Type())
		}
		arr := v.AsArray()
		if len(arr) != 0 {
			t.Errorf("expected empty array, got %d elements", len(arr))
		}
	})

	t.Run("array-dense", func(t *testing.T) {
		binData, _ := loadFixture(t, "array-dense")
		v, err := Deserialize(binData)
		if err != nil {
			t.Fatalf("Deserialize failed: %v", err)
		}
		arr := v.AsArray()
		if len(arr) != 3 {
			t.Fatalf("expected 3 elements, got %d", len(arr))
		}
		for i, expected := range []int32{1, 2, 3} {
			if arr[i].AsInt32() != expected {
				t.Errorf("arr[%d]: expected %d, got %v", i, expected, arr[i])
			}
		}
	})

	t.Run("array-nested", func(t *testing.T) {
		binData, _ := loadFixture(t, "array-nested")
		v, err := Deserialize(binData)
		if err != nil {
			t.Fatalf("Deserialize failed: %v", err)
		}
		arr := v.AsArray()
		if len(arr) != 2 {
			t.Fatalf("expected 2 elements, got %d", len(arr))
		}
		inner := arr[0].AsArray()
		if inner[0].AsInt32() != 1 || inner[1].AsInt32() != 2 {
			t.Errorf("arr[0]: expected [1,2], got %v", inner)
		}
	})

	t.Run("array-sparse", func(t *testing.T) {
		binData, _ := loadFixture(t, "array-sparse")
		v, err := Deserialize(binData)
		if err != nil {
			t.Fatalf("Deserialize failed: %v", err)
		}
		arr := v.AsArray()
		if len(arr) != 11 {
			t.Fatalf("expected 11 elements, got %d", len(arr))
		}
		// Check holes
		if !arr[1].IsHole() {
			t.Errorf("arr[1]: expected hole, got %v", arr[1])
		}
		if !arr[2].IsHole() {
			t.Errorf("arr[2]: expected hole, got %v", arr[2])
		}
		// Check values
		if arr[0].AsInt32() != 1 {
			t.Errorf("arr[0]: expected 1, got %v", arr[0])
		}
		if arr[10].AsInt32() != 11 {
			t.Errorf("arr[10]: expected 11, got %v", arr[10])
		}
	})
}

func TestDeserializeMaps(t *testing.T) {
	t.Run("map-empty", func(t *testing.T) {
		binData, _ := loadFixture(t, "map-empty")
		v, err := Deserialize(binData)
		if err != nil {
			t.Fatalf("Deserialize failed: %v", err)
		}
		if v.Type() != TypeMap {
			t.Fatalf("expected TypeMap, got %s", v.Type())
		}
		m := v.Interface().(*JSMap)
		if len(m.Entries) != 0 {
			t.Errorf("expected empty map, got %d entries", len(m.Entries))
		}
	})

	t.Run("map-strings", func(t *testing.T) {
		binData, _ := loadFixture(t, "map-strings")
		v, err := Deserialize(binData)
		if err != nil {
			t.Fatalf("Deserialize failed: %v", err)
		}
		m := v.Interface().(*JSMap)
		if len(m.Entries) != 2 {
			t.Fatalf("expected 2 entries, got %d", len(m.Entries))
		}
		// Check first entry
		if m.Entries[0].Key.AsString() != "key1" {
			t.Errorf("entry 0 key: expected 'key1', got %v", m.Entries[0].Key)
		}
		if m.Entries[0].Value.AsString() != "value1" {
			t.Errorf("entry 0 value: expected 'value1', got %v", m.Entries[0].Value)
		}
	})
}

func TestDeserializeSets(t *testing.T) {
	t.Run("set-empty", func(t *testing.T) {
		binData, _ := loadFixture(t, "set-empty")
		v, err := Deserialize(binData)
		if err != nil {
			t.Fatalf("Deserialize failed: %v", err)
		}
		if v.Type() != TypeSet {
			t.Fatalf("expected TypeSet, got %s", v.Type())
		}
		s := v.Interface().(*JSSet)
		if len(s.Values) != 0 {
			t.Errorf("expected empty set, got %d values", len(s.Values))
		}
	})

	t.Run("set-numbers", func(t *testing.T) {
		binData, _ := loadFixture(t, "set-numbers")
		v, err := Deserialize(binData)
		if err != nil {
			t.Fatalf("Deserialize failed: %v", err)
		}
		s := v.Interface().(*JSSet)
		if len(s.Values) != 3 {
			t.Fatalf("expected 3 values, got %d", len(s.Values))
		}
	})
}

func TestDeserializeCircularReferences(t *testing.T) {
	t.Run("circular-self", func(t *testing.T) {
		binData, _ := loadFixture(t, "circular-self")
		v, err := Deserialize(binData)
		if err != nil {
			t.Fatalf("Deserialize failed: %v", err)
		}
		obj := v.AsObject()
		if obj["name"].AsString() != "self" {
			t.Errorf("name: expected 'self', got %v", obj["name"])
		}
		// Check circular reference
		selfRef := obj["self"]
		if selfRef.Type() != TypeObject {
			t.Fatalf("self: expected object, got %s", selfRef.Type())
		}
		// The self reference should be the same object
		if selfRef.AsObject()["name"].AsString() != "self" {
			t.Errorf("self.name: expected 'self', got %v", selfRef.AsObject()["name"])
		}
	})

	t.Run("circular-array", func(t *testing.T) {
		binData, _ := loadFixture(t, "circular-array")
		v, err := Deserialize(binData)
		if err != nil {
			t.Fatalf("Deserialize failed: %v", err)
		}
		arr := v.AsArray()
		if len(arr) != 4 {
			t.Fatalf("expected 4 elements, got %d", len(arr))
		}
		if arr[0].AsInt32() != 1 {
			t.Errorf("arr[0]: expected 1, got %v", arr[0])
		}
		// arr[3] should be the array itself
		if arr[3].Type() != TypeArray {
			t.Fatalf("arr[3]: expected array, got %s", arr[3].Type())
		}
	})
}

// TestCircularReferenceSafetyGoString verifies that GoString doesn't infinite loop
// on circular references. This is a safety test for fmt.Sprintf("%#v", val).
func TestCircularReferenceSafetyGoString(t *testing.T) {
	// Test self-referencing object
	t.Run("circular-self", func(t *testing.T) {
		binData, _ := loadFixture(t, "circular-self")
		v, err := Deserialize(binData)
		if err != nil {
			t.Fatalf("Deserialize failed: %v", err)
		}

		// This should complete quickly without hanging
		done := make(chan string, 1)
		go func() {
			done <- v.GoString()
		}()

		select {
		case s := <-done:
			t.Logf("GoString returned: %s", s)
		case <-time.After(time.Second):
			t.Fatal("GoString timed out - possible infinite loop")
		}
	})

	// Test circular array
	t.Run("circular-array", func(t *testing.T) {
		binData, _ := loadFixture(t, "circular-array")
		v, err := Deserialize(binData)
		if err != nil {
			t.Fatalf("Deserialize failed: %v", err)
		}

		done := make(chan string, 1)
		go func() {
			done <- v.GoString()
		}()

		select {
		case s := <-done:
			t.Logf("GoString returned: %s", s)
		case <-time.After(time.Second):
			t.Fatal("GoString timed out - possible infinite loop")
		}
	})

	// Test deep circular
	t.Run("circular-deep", func(t *testing.T) {
		binData, _ := loadFixture(t, "circular-deep")
		v, err := Deserialize(binData)
		if err != nil {
			t.Fatalf("Deserialize failed: %v", err)
		}

		done := make(chan string, 1)
		go func() {
			done <- v.GoString()
		}()

		select {
		case s := <-done:
			t.Logf("GoString returned: %s", s)
		case <-time.After(time.Second):
			t.Fatal("GoString timed out - possible infinite loop")
		}
	})
}

func TestDeserializeArrayBuffer(t *testing.T) {
	t.Run("arraybuffer-empty", func(t *testing.T) {
		binData, _ := loadFixture(t, "arraybuffer-empty")
		v, err := Deserialize(binData)
		if err != nil {
			t.Fatalf("Deserialize failed: %v", err)
		}
		if v.Type() != TypeArrayBuffer {
			t.Fatalf("expected TypeArrayBuffer, got %s", v.Type())
		}
		buf := v.Interface().([]byte)
		if len(buf) != 0 {
			t.Errorf("expected empty buffer, got %d bytes", len(buf))
		}
	})

	t.Run("arraybuffer-data", func(t *testing.T) {
		binData, _ := loadFixture(t, "arraybuffer-data")
		v, err := Deserialize(binData)
		if err != nil {
			t.Fatalf("Deserialize failed: %v", err)
		}
		buf := v.Interface().([]byte)
		expected := []byte{1, 2, 3, 4}
		if len(buf) != len(expected) {
			t.Fatalf("expected %d bytes, got %d", len(expected), len(buf))
		}
		for i := range expected {
			if buf[i] != expected[i] {
				t.Errorf("buf[%d]: expected %d, got %d", i, expected[i], buf[i])
			}
		}
	})
}

func TestDeserializeTypedArrays(t *testing.T) {
	t.Run("uint8array", func(t *testing.T) {
		binData, _ := loadFixture(t, "uint8array")
		v, err := Deserialize(binData)
		if err != nil {
			t.Fatalf("Deserialize failed: %v", err)
		}
		if v.Type() != TypeTypedArray {
			t.Fatalf("expected TypeTypedArray, got %s", v.Type())
		}
		view := v.Interface().(*ArrayBufferView)
		if view.Type != "Uint8Array" {
			t.Errorf("expected Uint8Array, got %s", view.Type)
		}
		expected := []byte{255, 0, 128}
		if len(view.Buffer) != len(expected) {
			t.Fatalf("expected %d bytes, got %d", len(expected), len(view.Buffer))
		}
		for i := range expected {
			if view.Buffer[i] != expected[i] {
				t.Errorf("buf[%d]: expected %d, got %d", i, expected[i], view.Buffer[i])
			}
		}
	})

	t.Run("int8array", func(t *testing.T) {
		binData, _ := loadFixture(t, "int8array")
		v, err := Deserialize(binData)
		if err != nil {
			t.Fatalf("Deserialize failed: %v", err)
		}
		view := v.Interface().(*ArrayBufferView)
		if view.Type != "Int8Array" {
			t.Errorf("expected Int8Array, got %s", view.Type)
		}
	})

	t.Run("float64array", func(t *testing.T) {
		binData, _ := loadFixture(t, "float64array")
		v, err := Deserialize(binData)
		if err != nil {
			t.Fatalf("Deserialize failed: %v", err)
		}
		view := v.Interface().(*ArrayBufferView)
		if view.Type != "Float64Array" {
			t.Errorf("expected Float64Array, got %s", view.Type)
		}
		if len(view.Buffer) != 16 {
			t.Errorf("expected 16 bytes, got %d", len(view.Buffer))
		}
	})
}

func TestDeserializeRegExp(t *testing.T) {
	t.Run("regexp-simple", func(t *testing.T) {
		binData, _ := loadFixture(t, "regexp-simple")
		v, err := Deserialize(binData)
		if err != nil {
			t.Fatalf("Deserialize failed: %v", err)
		}
		if v.Type() != TypeRegExp {
			t.Fatalf("expected TypeRegExp, got %s", v.Type())
		}
		re := v.Interface().(*RegExp)
		if re.Pattern != "hello" {
			t.Errorf("pattern: expected 'hello', got %q", re.Pattern)
		}
		if re.Flags != "" {
			t.Errorf("flags: expected empty, got %q", re.Flags)
		}
	})

	t.Run("regexp-flags", func(t *testing.T) {
		binData, _ := loadFixture(t, "regexp-flags")
		v, err := Deserialize(binData)
		if err != nil {
			t.Fatalf("Deserialize failed: %v", err)
		}
		re := v.Interface().(*RegExp)
		if re.Pattern != "pattern.*test" {
			t.Errorf("pattern: expected 'pattern.*test', got %q", re.Pattern)
		}
		// Flags should be "gi" (global, ignoreCase)
		if re.Flags != "gi" {
			t.Errorf("flags: expected 'gi', got %q", re.Flags)
		}
	})
}

func TestDeserializeBoxedPrimitives(t *testing.T) {
	t.Run("boxed-number", func(t *testing.T) {
		binData, _ := loadFixture(t, "boxed-number")
		v, err := Deserialize(binData)
		if err != nil {
			t.Fatalf("Deserialize failed: %v", err)
		}
		if v.Type() != TypeBoxedPrimitive {
			t.Fatalf("expected TypeBoxedPrimitive, got %s", v.Type())
		}
		boxed := v.Interface().(*BoxedPrimitive)
		if boxed.Value.AsDouble() != 42 {
			t.Errorf("expected 42, got %v", boxed.Value)
		}
	})

	t.Run("boxed-boolean-true", func(t *testing.T) {
		binData, _ := loadFixture(t, "boxed-boolean-true")
		v, err := Deserialize(binData)
		if err != nil {
			t.Fatalf("Deserialize failed: %v", err)
		}
		boxed := v.Interface().(*BoxedPrimitive)
		if !boxed.Value.AsBool() {
			t.Errorf("expected true")
		}
	})

	t.Run("boxed-boolean-false", func(t *testing.T) {
		binData, _ := loadFixture(t, "boxed-boolean-false")
		v, err := Deserialize(binData)
		if err != nil {
			t.Fatalf("Deserialize failed: %v", err)
		}
		boxed := v.Interface().(*BoxedPrimitive)
		if boxed.Value.AsBool() {
			t.Errorf("expected false")
		}
	})

	t.Run("boxed-string", func(t *testing.T) {
		binData, _ := loadFixture(t, "boxed-string")
		v, err := Deserialize(binData)
		if err != nil {
			t.Fatalf("Deserialize failed: %v", err)
		}
		boxed := v.Interface().(*BoxedPrimitive)
		if boxed.Value.AsString() != "wrapped" {
			t.Errorf("expected 'wrapped', got %v", boxed.Value)
		}
	})
}

func TestDeserializeErrors(t *testing.T) {
	tests := []struct {
		fixture string
		errName string
		message string
	}{
		{"error-simple", "Error", "simple error"},
		{"error-type", "TypeError", "type error"},
		{"error-range", "RangeError", "range error"},
		{"error-syntax", "SyntaxError", "syntax error"},
		{"error-reference", "ReferenceError", "ref error"},
	}

	for _, tt := range tests {
		t.Run(tt.fixture, func(t *testing.T) {
			binData, _ := loadFixture(t, tt.fixture)
			v, err := Deserialize(binData)
			if err != nil {
				t.Fatalf("Deserialize failed: %v", err)
			}
			if v.Type() != TypeError {
				t.Fatalf("expected TypeError, got %s", v.Type())
			}
			jsErr := v.Interface().(*JSError)
			if jsErr.Name != tt.errName {
				t.Errorf("name: got %q, want %q", jsErr.Name, tt.errName)
			}
			if jsErr.Message != tt.message {
				t.Errorf("message: got %q, want %q", jsErr.Message, tt.message)
			}
			if jsErr.Stack == "" {
				t.Error("expected non-empty stack")
			}
			t.Logf("Error: %s: %s", jsErr.Name, jsErr.Message)
		})
	}
}

func TestToGo(t *testing.T) {
	t.Run("primitives", func(t *testing.T) {
		if ToGo(Null()) != nil {
			t.Error("expected nil for null")
		}
		if ToGo(Undefined()) != nil {
			t.Error("expected nil for undefined")
		}
		if ToGo(Bool(true)) != true {
			t.Error("expected true")
		}
		if ToGo(Int32(42)).(int32) != 42 {
			t.Error("expected 42")
		}
		if ToGo(String("hello")).(string) != "hello" {
			t.Error("expected 'hello'")
		}
	})

	t.Run("object", func(t *testing.T) {
		binData, _ := loadFixture(t, "object-simple")
		v, _ := Deserialize(binData)
		result := ToGo(v).(map[string]interface{})
		if result["a"].(int32) != 1 {
			t.Errorf("a: expected 1, got %v", result["a"])
		}
		if result["b"].(int32) != 2 {
			t.Errorf("b: expected 2, got %v", result["b"])
		}
	})

	t.Run("array", func(t *testing.T) {
		binData, _ := loadFixture(t, "array-dense")
		v, _ := Deserialize(binData)
		result := ToGo(v).([]interface{})
		if len(result) != 3 {
			t.Fatalf("expected 3 elements, got %d", len(result))
		}
		if result[0].(int32) != 1 {
			t.Errorf("arr[0]: expected 1, got %v", result[0])
		}
	})
}

func TestMustDeserialize(t *testing.T) {
	t.Run("valid", func(t *testing.T) {
		binData, _ := loadFixture(t, "int32-positive")
		v := MustDeserialize(binData)
		if v.AsInt32() != 42 {
			t.Errorf("expected 42, got %v", v.AsInt32())
		}
	})

	t.Run("invalid panics", func(t *testing.T) {
		defer func() {
			if r := recover(); r == nil {
				t.Error("expected panic")
			}
		}()
		MustDeserialize([]byte{0x00, 0x01})
	})
}

func TestIsValidV8Data(t *testing.T) {
	tests := []struct {
		name  string
		data  []byte
		valid bool
	}{
		{"empty", []byte{}, false},
		{"too short", []byte{0xFF}, false},
		{"valid v15", []byte{0xFF, 0x0F, 0x30}, true},
		{"valid v13", []byte{0xFF, 0x0D, 0x30}, true},
		{"wrong tag", []byte{0xFE, 0x0F, 0x30}, false},
		{"version too old", []byte{0xFF, 0x0C, 0x30}, false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := IsValidV8Data(tt.data); got != tt.valid {
				t.Errorf("IsValidV8Data() = %v, want %v", got, tt.valid)
			}
		})
	}
}

// Benchmark deserialization
func BenchmarkDeserializeInt32(b *testing.B) {
	binData, _ := os.ReadFile(filepath.Join("..", "..", "testdata", "fixtures", "int32-positive.bin"))
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		Deserialize(binData)
	}
}

func BenchmarkDeserializeString(b *testing.B) {
	binData, _ := os.ReadFile(filepath.Join("..", "..", "testdata", "fixtures", "string-hello-world.bin"))
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		Deserialize(binData)
	}
}

func BenchmarkDeserializeLongString(b *testing.B) {
	binData, _ := os.ReadFile(filepath.Join("..", "..", "testdata", "fixtures", "string-256-twobyte.bin"))
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		Deserialize(binData)
	}
}

func BenchmarkDeserializeObject(b *testing.B) {
	binData, _ := os.ReadFile(filepath.Join("..", "..", "testdata", "fixtures", "object-types.bin"))
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		Deserialize(binData)
	}
}

func BenchmarkDeserializeArray(b *testing.B) {
	binData, _ := os.ReadFile(filepath.Join("..", "..", "testdata", "fixtures", "array-nested.bin"))
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		Deserialize(binData)
	}
}

// BenchmarkDeserializeLargePayload benchmarks deserialization of large payloads.
// These are synthetic benchmarks using programmatically generated data.
func BenchmarkDeserializeLargePayload(b *testing.B) {
	// Helper to generate a large object with many keys
	generateLargeObject := func(numKeys int) Value {
		props := make(map[string]Value, numKeys)
		for i := 0; i < numKeys; i++ {
			key := fmt.Sprintf("key%d", i)
			props[key] = Int32(int32(i))
		}
		return Object(props)
	}

	// Helper to generate a large array
	generateLargeArray := func(size int) Value {
		elements := make([]Value, size)
		for i := 0; i < size; i++ {
			elements[i] = Int32(int32(i))
		}
		return Array(elements)
	}

	// Helper to generate deeply nested object
	generateDeepObject := func(depth int) Value {
		result := Object(map[string]Value{"value": Int32(0)})
		for i := 0; i < depth; i++ {
			result = Object(map[string]Value{
				"level":  Int32(int32(i)),
				"nested": result,
			})
		}
		return result
	}

	benchmarks := []struct {
		name      string
		generator func() Value
	}{
		{"Object-100keys", func() Value { return generateLargeObject(100) }},
		{"Object-1000keys", func() Value { return generateLargeObject(1000) }},
		{"Object-10000keys", func() Value { return generateLargeObject(10000) }},
		{"Array-1000elements", func() Value { return generateLargeArray(1000) }},
		{"Array-10000elements", func() Value { return generateLargeArray(10000) }},
		{"Array-100000elements", func() Value { return generateLargeArray(100000) }},
		{"DeepNested-100", func() Value { return generateDeepObject(100) }},
		{"DeepNested-500", func() Value { return generateDeepObject(500) }},
	}

	for _, bm := range benchmarks {
		b.Run(bm.name, func(b *testing.B) {
			// Serialize the test value
			v := bm.generator()
			data, err := Serialize(v)
			if err != nil {
				b.Fatalf("Serialize failed: %v", err)
			}
			b.SetBytes(int64(len(data)))
			b.ReportMetric(float64(len(data)), "bytes")

			b.ResetTimer()
			for i := 0; i < b.N; i++ {
				_, err := Deserialize(data)
				if err != nil {
					b.Fatal(err)
				}
			}
		})
	}
}

// BenchmarkSerializeLargePayload benchmarks serialization of large payloads.
func BenchmarkSerializeLargePayload(b *testing.B) {
	// Helper to generate a large object with many keys
	generateLargeObject := func(numKeys int) Value {
		props := make(map[string]Value, numKeys)
		for i := 0; i < numKeys; i++ {
			key := fmt.Sprintf("key%d", i)
			props[key] = Int32(int32(i))
		}
		return Object(props)
	}

	// Helper to generate a large array
	generateLargeArray := func(size int) Value {
		elements := make([]Value, size)
		for i := 0; i < size; i++ {
			elements[i] = Int32(int32(i))
		}
		return Array(elements)
	}

	benchmarks := []struct {
		name      string
		generator func() Value
	}{
		{"Object-100keys", func() Value { return generateLargeObject(100) }},
		{"Object-1000keys", func() Value { return generateLargeObject(1000) }},
		{"Array-1000elements", func() Value { return generateLargeArray(1000) }},
		{"Array-10000elements", func() Value { return generateLargeArray(10000) }},
	}

	for _, bm := range benchmarks {
		b.Run(bm.name, func(b *testing.B) {
			v := bm.generator()

			// Serialize once to get byte count
			data, _ := Serialize(v)
			b.SetBytes(int64(len(data)))

			b.ResetTimer()
			for i := 0; i < b.N; i++ {
				Serialize(v)
			}
		})
	}
}

// Tests for new fixtures and features

func TestDeserializeObjectWithNumericKeys(t *testing.T) {
	binData, _ := loadFixture(t, "object-numeric-keys")
	v, err := Deserialize(binData)
	if err != nil {
		t.Fatalf("Deserialize failed: %v", err)
	}
	obj := v.AsObject()
	if obj["0"].AsString() != "zero" {
		t.Errorf("key '0': expected 'zero', got %v", obj["0"])
	}
	if obj["1"].AsString() != "one" {
		t.Errorf("key '1': expected 'one', got %v", obj["1"])
	}
}

func TestDeserializeLargeSparseArray(t *testing.T) {
	binData, _ := loadFixture(t, "array-large-sparse")
	v, err := Deserialize(binData)
	if err != nil {
		t.Fatalf("Deserialize failed: %v", err)
	}
	arr := v.AsArray()
	if len(arr) != 10000 {
		t.Fatalf("expected 10000 elements, got %d", len(arr))
	}
	if arr[0].AsString() != "first" {
		t.Errorf("arr[0]: expected 'first', got %v", arr[0])
	}
	if arr[5000].AsString() != "middle" {
		t.Errorf("arr[5000]: expected 'middle', got %v", arr[5000])
	}
	if arr[9999].AsString() != "last" {
		t.Errorf("arr[9999]: expected 'last', got %v", arr[9999])
	}
	// Check that most elements are holes
	if !arr[1].IsHole() {
		t.Errorf("arr[1]: expected hole, got %v", arr[1])
	}
}

func TestDeserializeArrayWithProperties(t *testing.T) {
	binData, _ := loadFixture(t, "array-with-properties")
	v, err := Deserialize(binData)
	if err != nil {
		t.Fatalf("Deserialize failed: %v", err)
	}
	arr := v.AsArray()
	if len(arr) != 3 {
		t.Fatalf("expected 3 elements, got %d", len(arr))
	}
	if arr[0].AsInt32() != 1 {
		t.Errorf("arr[0]: expected 1, got %v", arr[0])
	}
}

func TestDeserializeDuplicateStringRefs(t *testing.T) {
	binData, _ := loadFixture(t, "string-duplicate-refs")
	v, err := Deserialize(binData)
	if err != nil {
		t.Fatalf("Deserialize failed: %v", err)
	}
	obj := v.AsObject()
	expected := "This string appears multiple times"
	if obj["a"].AsString() != expected {
		t.Errorf("a: expected %q, got %q", expected, obj["a"].AsString())
	}
	if obj["b"].AsString() != expected {
		t.Errorf("b: expected %q, got %q", expected, obj["b"].AsString())
	}
	if obj["c"].AsString() != expected {
		t.Errorf("c: expected %q, got %q", expected, obj["c"].AsString())
	}
}

func TestDeserializeManyStringRefs(t *testing.T) {
	binData, _ := loadFixture(t, "string-many-refs")
	v, err := Deserialize(binData)
	if err != nil {
		t.Fatalf("Deserialize failed: %v", err)
	}
	obj := v.AsObject()
	if len(obj) != 100 {
		t.Fatalf("expected 100 keys, got %d", len(obj))
	}
	for i := 0; i < 100; i++ {
		key := fmt.Sprintf("key%d", i)
		if obj[key].AsString() != "repeated" {
			t.Errorf("%s: expected 'repeated', got %v", key, obj[key])
		}
	}
}

func TestDeserializeBigInt64Array(t *testing.T) {
	binData, _ := loadFixture(t, "bigint64array")
	v, err := Deserialize(binData)
	if err != nil {
		t.Fatalf("Deserialize failed: %v", err)
	}
	if v.Type() != TypeTypedArray {
		t.Fatalf("expected TypeTypedArray, got %s", v.Type())
	}
	view := v.Interface().(*ArrayBufferView)
	if view.Type != "BigInt64Array" {
		t.Errorf("expected BigInt64Array, got %s", view.Type)
	}
	// Each BigInt64 is 8 bytes, 4 elements = 32 bytes
	if len(view.Buffer) != 32 {
		t.Errorf("expected 32 bytes, got %d", len(view.Buffer))
	}
}

func TestDeserializeBigUint64Array(t *testing.T) {
	binData, _ := loadFixture(t, "biguint64array")
	v, err := Deserialize(binData)
	if err != nil {
		t.Fatalf("Deserialize failed: %v", err)
	}
	view := v.Interface().(*ArrayBufferView)
	if view.Type != "BigUint64Array" {
		t.Errorf("expected BigUint64Array, got %s", view.Type)
	}
	// 3 elements = 24 bytes
	if len(view.Buffer) != 24 {
		t.Errorf("expected 24 bytes, got %d", len(view.Buffer))
	}
}

func TestDeserializeDataView(t *testing.T) {
	binData, _ := loadFixture(t, "dataview")
	v, err := Deserialize(binData)
	if err != nil {
		t.Fatalf("Deserialize failed: %v", err)
	}
	if v.Type() != TypeTypedArray {
		t.Fatalf("expected TypeTypedArray, got %s", v.Type())
	}
	view := v.Interface().(*ArrayBufferView)
	if view.Type != "DataView" {
		t.Errorf("expected DataView, got %s", view.Type)
	}
	if len(view.Buffer) != 16 {
		t.Errorf("expected 16 bytes, got %d", len(view.Buffer))
	}
}

func TestDeserializeDeepNestedObject(t *testing.T) {
	binData, _ := loadFixture(t, "object-deep-100")
	v, err := Deserialize(binData)
	if err != nil {
		t.Fatalf("Deserialize failed: %v", err)
	}

	// Traverse to depth 100
	current := v
	for i := 99; i >= 0; i-- {
		if current.Type() != TypeObject {
			t.Fatalf("depth %d: expected object, got %s", i, current.Type())
		}
		obj := current.AsObject()
		if obj["level"].AsInt32() != int32(i) {
			t.Errorf("level %d: expected level %d, got %v", i, i, obj["level"])
		}
		current = obj["nested"]
	}

	// At the bottom, we should have the value
	finalObj := current.AsObject()
	if finalObj["value"].AsString() != "bottom" {
		t.Errorf("bottom: expected 'bottom', got %v", finalObj["value"])
	}
}

func TestMaxDepthLimit(t *testing.T) {
	binData, _ := loadFixture(t, "object-deep-100")

	// With depth limit of 50, should fail
	_, err := Deserialize(binData, WithMaxDepth(50))
	if err == nil {
		t.Fatal("expected max depth error")
	}
	if !strings.Contains(err.Error(), "max depth") {
		t.Errorf("expected max depth error, got: %v", err)
	}

	// With depth limit of 200, should succeed
	_, err = Deserialize(binData, WithMaxDepth(200))
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
}

func TestMaxSizeLimit(t *testing.T) {
	binData, _ := loadFixture(t, "string-10k")

	// With size limit smaller than data, should fail
	_, err := Deserialize(binData, WithMaxSize(100))
	if err == nil {
		t.Fatal("expected max size error")
	}
	if !strings.Contains(err.Error(), "max size") {
		t.Errorf("expected max size error, got: %v", err)
	}

	// With size limit larger than data, should succeed
	_, err = Deserialize(binData, WithMaxSize(20000))
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
}

func TestDeserializeSetOfObjects(t *testing.T) {
	binData, _ := loadFixture(t, "set-objects")
	v, err := Deserialize(binData)
	if err != nil {
		t.Fatalf("Deserialize failed: %v", err)
	}
	if v.Type() != TypeSet {
		t.Fatalf("expected TypeSet, got %s", v.Type())
	}
	s := v.Interface().(*JSSet)
	if len(s.Values) != 3 {
		t.Fatalf("expected 3 values, got %d", len(s.Values))
	}
	// Each value should be an object with an 'id' property (1, 2, 3)
	for i, val := range s.Values {
		obj := val.AsObject()
		expected := int32(i + 1)
		if obj["id"].AsInt32() != expected {
			t.Errorf("set[%d].id: expected %d, got %v", i, expected, obj["id"])
		}
	}
}

func TestDeserializeSetWithCircular(t *testing.T) {
	binData, _ := loadFixture(t, "set-circular")
	v, err := Deserialize(binData)
	if err != nil {
		t.Fatalf("Deserialize failed: %v", err)
	}
	s := v.Interface().(*JSSet)
	if len(s.Values) != 1 {
		t.Fatalf("expected 1 value, got %d", len(s.Values))
	}
	// The value should be an object with a 'set' property pointing to the set
	obj := s.Values[0].AsObject()
	innerSet := obj["set"]
	if innerSet.Type() != TypeSet {
		t.Errorf("expected TypeSet, got %s", innerSet.Type())
	}
}

func TestDeserializeVeryLongString(t *testing.T) {
	binData, _ := loadFixture(t, "string-10k")
	v, err := Deserialize(binData)
	if err != nil {
		t.Fatalf("Deserialize failed: %v", err)
	}
	s := v.AsString()
	if len(s) != 10000 {
		t.Errorf("expected 10000 chars, got %d", len(s))
	}
	// All characters should be 'x'
	for i, c := range s {
		if c != 'x' {
			t.Errorf("char %d: expected 'x', got %c", i, c)
			break
		}
	}
}

func TestDeserializeUnpairedSurrogates(t *testing.T) {
	// These should deserialize without error (V8 allows them)
	tests := []string{
		"string-unpaired-high-surrogate",
		"string-unpaired-low-surrogate",
		"string-replacement-char",
	}
	for _, fixture := range tests {
		t.Run(fixture, func(t *testing.T) {
			binData, _ := loadFixture(t, fixture)
			_, err := Deserialize(binData)
			if err != nil {
				t.Fatalf("Deserialize failed: %v", err)
			}
		})
	}
}

// Tests for edge cases from Deno v8_valueserializer
func TestDeserializeEdgeCases(t *testing.T) {
	// Test fixtures that should all deserialize without error
	fixtures := []struct {
		name        string
		description string
	}{
		{"string-with-null", "string containing null byte"},
		{"string-unpaired-surrogate-context", "unpaired surrogate with context"},
		{"bigint-u128-max", "128-bit BigInt"},
		{"regexp-empty", "empty RegExp"},
		{"regexp-emoji", "RegExp with emoji"},
		{"date-invalid", "invalid Date (NaN)"},
		{"object-smi-keys", "object with SMI property keys"},
		{"array-sparse-explicit", "sparse array with explicit length"},
		{"array-sparse-with-props", "sparse array with custom properties"},
		{"array-dense-circular-self", "dense array referencing itself"},
		{"uint8array-subarray", "Uint8Array subarray"},
		{"int32array-subarray", "Int32Array subarray"},
		{"float64array-subarray", "Float64Array subarray"},
		{"float32array-special-values", "Float32Array with special values"},
		{"float64array-special-values", "Float64Array with special values"},
		{"dataview-with-offset", "DataView with byte offset"},
		{"error-no-stack", "Error with stack deleted"},
		{"error-cause-primitive", "Error with primitive cause"},
		{"error-cause-object", "Error with object cause"},
		{"array-shared-strings", "array of objects sharing strings"},
		{"set-circular-obj", "Set with circular reference"},
		{"boxed-number-nan", "boxed Number(NaN)"},
		{"boxed-number-infinity", "boxed Number(Infinity)"},
		{"boxed-number-neg-zero", "boxed Number(-0)"},
		{"map-non-string-keys", "Map with non-string keys"},
		{"set-mixed-types", "Set with mixed types"},
		{"typed-array-multi-views", "multiple TypedArray views"},
		// ResizableArrayBuffer (tag ~) not implemented yet - skip
		// {"arraybuffer-resizable", "ResizableArrayBuffer"},
		// {"uint8array-resizable", "Uint8Array on ResizableArrayBuffer"},
	}

	for _, tc := range fixtures {
		t.Run(tc.name, func(t *testing.T) {
			binData, _ := loadFixture(t, tc.name)

			v, err := Deserialize(binData)
			if err != nil {
				t.Fatalf("Deserialize failed for %s: %v", tc.description, err)
			}

			// Verify the value is usable
			_ = v.Type()
			_ = v.GoString()
		})
	}
}

func TestDeserializeInvalidDate(t *testing.T) {
	binData, _ := loadFixture(t, "date-invalid")
	v, err := Deserialize(binData)
	if err != nil {
		t.Fatalf("Deserialize failed: %v", err)
	}

	if v.Type() != TypeDate {
		t.Fatalf("expected Date, got %s", v.Type())
	}

	// Invalid dates should have a time value of NaN, which in Go becomes Unix time 0
	date := v.AsDate()
	if !date.IsZero() {
		// Or check if it's a very weird value
		t.Logf("Invalid date deserialized to: %v", date)
	}
}

func TestDeserializeBigIntU128Max(t *testing.T) {
	binData, _ := loadFixture(t, "bigint-u128-max")
	v, err := Deserialize(binData)
	if err != nil {
		t.Fatalf("Deserialize failed: %v", err)
	}

	if v.Type() != TypeBigInt {
		t.Fatalf("expected BigInt, got %s", v.Type())
	}

	expected := "340282366920938463463374607431768211455"
	if v.AsBigInt().String() != expected {
		t.Errorf("expected %s, got %s", expected, v.AsBigInt().String())
	}
}

func TestDeserializeTypedArraySubarray(t *testing.T) {
	binData, _ := loadFixture(t, "uint8array-subarray")
	v, err := Deserialize(binData)
	if err != nil {
		t.Fatalf("Deserialize failed: %v", err)
	}

	if v.Type() != TypeTypedArray {
		t.Fatalf("expected TypedArray, got %s", v.Type())
	}

	view := v.Interface().(*ArrayBufferView)
	if view.Type != "Uint8Array" {
		t.Errorf("expected Uint8Array, got %s", view.Type)
	}
	// subarray(1, 3) of [1,2,3,4] should be 2 bytes
	if view.ByteLength != 2 {
		t.Errorf("expected byteLength 2, got %d", view.ByteLength)
	}
}

// TestDeserializeLatin1EdgeCases tests Latin-1 string encoding edge cases
// These tests verify correct handling of the Latin-1 character range (0x80-0xFF)
func TestDeserializeLatin1EdgeCases(t *testing.T) {
	tests := []struct {
		fixture  string
		expected string
	}{
		{"string-latin1-0x80", "\u0080"},
		{"string-latin1-0xFF", "\u00FF"},
		{"string-latin1-aumlaut", "\u00E4"},                                  // √§
		{"string-latin1-oumlaut", "\u00F6"},                                  // √∂
		{"string-latin1-uumlaut", "\u00FC"},                                  // √º
		{"string-latin1-eszett", "\u00DF"},                                   // √ü
		{"string-latin1-symbols", "\u00A0\u00A9\u00AE\u00B0"},                // NBSP ¬© ¬Æ ¬∞
		{"string-latin1-accented-A", "\u00C0\u00C1\u00C2\u00C3\u00C4\u00C5"}, // √Ä√Å√Ç√É√Ñ√Ö
		{"string-latin1-accented-a", "\u00E0\u00E1\u00E2\u00E3\u00E4\u00E5"}, // √†√°√¢√£√§√•
		{"string-latin1-words", "M\u00FCnchen Caf\u00E9 na\u00EFve"},         // M√ºnchen Caf√© na√Øve
		{"string-ascii-del", "\u007F"},
		{"string-mixed-ascii-latin1", "ABC\u00C4\u00D6\u00DC123"},    // ABC√Ñ√ñ√ú123
		{"string-latin1-currency", "Price: \u00A31.99 (\u00A92024)"}, // Price: ¬£1.99 (¬©2024)
		{"string-latin1-multi-utf8-chars", "\u00C3\u00A4"},           // √É√§
	}

	for _, tt := range tests {
		t.Run(tt.fixture, func(t *testing.T) {
			binData, _ := loadFixture(t, tt.fixture)
			v, err := Deserialize(binData)
			if err != nil {
				t.Fatalf("Deserialize failed: %v", err)
			}
			if v.Type() != TypeString {
				t.Fatalf("expected TypeString, got %s", v.Type())
			}
			if got := v.AsString(); got != tt.expected {
				t.Errorf("got %q (%x), expected %q (%x)",
					got, []byte(got), tt.expected, []byte(tt.expected))
			}
		})
	}
}

func TestDeserializeLatin1FullRange(t *testing.T) {
	binData, _ := loadFixture(t, "string-latin1-full-range")
	v, err := Deserialize(binData)
	if err != nil {
		t.Fatalf("Deserialize failed: %v", err)
	}

	if v.Type() != TypeString {
		t.Fatalf("expected TypeString, got %s", v.Type())
	}

	s := v.AsString()
	// Should contain 128 characters (0x80-0xFF)
	runes := []rune(s)
	if len(runes) != 128 {
		t.Fatalf("expected 128 runes, got %d", len(runes))
	}

	// Verify each character
	for i, r := range runes {
		expected := rune(0x80 + i)
		if r != expected {
			t.Errorf("rune %d: expected U+%04X, got U+%04X", i, expected, r)
		}
	}
}

func TestDeserializeFirstNonLatin1(t *testing.T) {
	binData, _ := loadFixture(t, "string-first-non-latin1")
	v, err := Deserialize(binData)
	if err != nil {
		t.Fatalf("Deserialize failed: %v", err)
	}

	if v.Type() != TypeString {
		t.Fatalf("expected TypeString, got %s", v.Type())
	}

	s := v.AsString()
	// U+0100 is the first character outside Latin-1, should be encoded as UTF-16
	if s != "\u0100" {
		t.Errorf("expected U+0100 (ƒÄ), got %q (%x)", s, []byte(s))
	}
}

// TestLatin1StringRoundTrip tests that Latin-1 strings round-trip correctly
func TestLatin1StringRoundTrip(t *testing.T) {
	tests := []struct {
		name  string
		value string
	}{
		{"caf√©", "caf√©"},
		{"√§√∂√º", "√§√∂√º"},
		{"german", "Gr√∂√üe"},
		{"french", "fran√ßais"},
		{"spanish", "se√±or"},
		{"swedish", "sm√∂rg√•s"},
		{"all-latin1-extended", "\u0080\u00A0\u00C0\u00E0\u00FF"},
		{"mixed", "ASCII \u00A9 2024 \u00AE"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Serialize
			data, err := Serialize(String(tt.value))
			if err != nil {
				t.Fatalf("Serialize failed: %v", err)
			}

			// Deserialize
			v, err := Deserialize(data)
			if err != nil {
				t.Fatalf("Deserialize failed: %v", err)
			}

			// Compare
			if v.Type() != TypeString {
				t.Fatalf("expected TypeString, got %s", v.Type())
			}
			if got := v.AsString(); got != tt.value {
				t.Errorf("round-trip mismatch:\n  got:  %q (%x)\n  want: %q (%x)",
					got, []byte(got), tt.value, []byte(tt.value))
			}
		})
	}
}
